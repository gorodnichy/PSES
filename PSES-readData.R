# source("PSES_functions.R")
# author: dg@ivim.ca 

# libraries & functions ------
if (T) {
  library(data.table, quietly=T)
  options(datatable.print.class=TRUE)
  #library(tidyverse) # includes: 
  library(readxl)
  library(magrittr)
  library(lubridate,  quietly=T)
  options(lubridate.week.start =  1)
  library(stringr)
  #library(tibble)
  library(ggplot2)
  library(png)
  
  
  getmode <- function(v) {   # mode
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
  }
  
  dt.getRows <- function(dt, rows) {     
    dt[rows]   }
  dt.getCols <- function(dt, columns) {
    if (column %>% is.integer() ) column <- names(dt)[column]
    dt[, .SD, .SDcols = column]  }
  
  if (F) { # TODO
    dt.getFor <- function(dt, keyed_values, upto=Inf, keys=NULL) {
      upto <- min(length(keyed_values, upto))
      keys <- ifelse(is.null(keys), dt %>% names, keys)
      setkeyv(dt, keys[1:upto])
      dt[as.list(keyed_values)]
    }
    
    # get children
    dt.getFor(dtDepartments, id[1:myLevel],keys=PSES_ID_COLS[1:myLevel])
    dt.getFor(dtDepartments, id[1:myLevel],upto=myLevel, keys=PSES_ID_COLS)
  }
  
}
# Later all this should be renames from my* to pses.*

# TODO: In Best OOP practices, this should be a Structure(aka List in R) or (better) R6 Class !!
# 

# 
# pses.init <- function()  {} # CPses$ 
# pses.init (). For now they need to be GLOBAL, so to use <<-


# my GLOBALS (x<<-a): dtPSES, dtQuestions, dtDepartments ----
if (T) {  
  
  
  PSES_ID_COLS = c("LEVEL1ID"  ,   "LEVEL2ID"    , "LEVEL3ID"   ,  "LEVEL4ID"   ,  "LEVEL5ID"  ); psesKeys = PSES_ID_COLS
  
  bPSES_READ <- F
  dtPSES <- data.table(); dtQuestions <- data.table(); dtDepartments <- data.table();  
  dtRESULT <- data.table();  dtAll <- data.table();
  
  myID.SE = c(1,200,0,0,0)
  myID0 = myID.SE 
  myID = myID0
  myLevel=1 #getLevel(myID)
  dtDeptSelected <- data.table();  
  
  myQ <- "Q43"
  myQs <- c("Q43", "Q42")
  myYears <- c(2018)
  myYear <- 2018
  
  myOrg <- ""
  
  input <- list()
  input$year <- myYear
  
  
  OPEN_CANADA_URL <- "https://www.canada.ca/content/dam/tbs-sct/documents/datasets/pses-saff/2018/2018_PSES_open_dataset_Ensemble_de_donn%C3%A9es_ouvertes_du_SAFF_2018.csv"
  
  
  #strCaptionCredits <- "Open Government Licence - Canada (https://open.canada.ca)"
  strCaptionCredits <-  paste0("2018 Public Service Employee Survey Results.\n License: Open Government Licence - Canada\n Generated on ", format(Sys.time(), "%d %B, %Y"), " by iTrack (https://itrack.shinyapps.io/PSES)")
  
  # strCaptionCredits <-  'Generated by iTrack (https://itrack.shinyapps.io/PSES)\nLicense: Open Government Licence - Canada'
  
  #  strCaptionCredits <- "Data  Source: https://open.canada.ca"
  strTitle <- NULL
  strSubtitle <- NULL
  
}

# PSES functions -----
ID2IDk <- function(...) { getIDupto(...) }
getIDupto <- function (id=myID, l=3) {
  # if (is.null(id))      id <-  myID
  if(l==0) {       return(rep(0,5))     } 
  if (l==5) {      return(id)
  } else {      c(id[1:l],rep(0,5-l)) 
  }
}
getIDupto()
getIDupto(c(28,34,604,10,255),3)  

ID2IDlevel <- function(...) { getLevel(...) }
getLevel <- function(id=myID) {
  which.min(id) - 1
}
getLevel()

Org2ID <- function(str=myOrg) {
  if(nrow(dtDepartments)!=0) {
    dtDepartments[Organization == str, (PSES_ID_COLS),with=F] %>% unlist;
    #return(  dtDepartments[ Organization==str, .(LEVEL1ID, LEVEL2ID, LEVEL3ID, LEVEL4ID,LEVEL5ID) ] %>% unlist() )
  }
}
Org2ID() 

ID2Org <- function(id=myID) {
  # if(nrow(dtDepartments)!=0) {
  setkeyv(dtDepartments,PSES_ID_COLS)
  return(dtDepartments[as.list(id)]$Organization)
  # }
}
ID2Org()

ID2Path <- function(id=myID) {
  # if(nrow(dtDepartments)!=0) {
  setkeyv(dtDepartments,PSES_ID_COLS)
  return(dtDepartments[as.list(id)]$pathString)
  # }
}


# getDept Children W/O (or WITH) yourself !
getDeptChildren<- function (id = myID, depth=Inf, yourself=F){
  
  setkeyv(dtDepartments, PSES_ID_COLS)
  levelID <- dtDepartments[as.list(id)]$IDlevel
  
  if (levelID==0)
    dt <- dtDepartments
  else {
    setkeyv(dtDepartments, PSES_ID_COLS[1:levelID])
    dt <- dtDepartments[as.list(id[1:levelID])]
    # OR dt <- dtDepartments[.(id[1:levelID])]  ????
  }
  if (!yourself) 
    dt <- dt [level!=levelID]
  
  dt <- dt [level<=levelID+depth]
  return(dt)
}
getDeptChildren()

# getDept Parents AND yourself !
getDeptParents <- function ( id = myID) {
  dtDepartments[
    (LEVEL1ID == 0 | LEVEL1ID == id[1] ) & 
      (LEVEL2ID == 0 | LEVEL2ID == id[2]) & 
      (LEVEL3ID == 0 | LEVEL3ID == id[3]) & 
      (LEVEL4ID == 0 | LEVEL4ID == id[4] )& 
      (LEVEL5ID == 0 | LEVEL5ID == id[5]  ) 
    ] 
}
getDeptParents()

getDeptAboveBelow <- function ( id = myID ) {
  rbind(getDeptParents(id),getDeptChildren(id))
}

# TODO rename : selectDepts -> selectDeptTree Or  getDeptsAboveBelow ()
selectDeptTree <- function ( id = myID) {
  
  if (  bPSES_READ==F) {
    print('getRESULTS(): PSES data NOT initialized ! -  Please Run readPsesData()')
    return (dtRESULT)
  } 
  
  myID <<- id
  # levelID <- dtDepartments[as.list(id)]$IDlevel
  myLevel <<- getLevel(myID)
  # setkeyv(dtDepartments, PSES_ID_COLS)
  # .levelID <- dtDepartments[as.list(id)]$IDlevel; 
  # .levelID <- myLevel
  
  if (myLevel==0) {
    dtDeptSelected <<- dtDepartments 
    return(dtDeptSelected)
  }
  
  setkeyv(dtDepartments, PSES_ID_COLS[1:myLevel]) 
  dtDeptSelected <<- 
    
    dtDepartments[as.list(id[1:myLevel])] %>% # get ALL children
    
    rbind(dtDepartments[                      # add ALL parents
      (LEVEL1ID == 0 | LEVEL1ID == id[1] ) & 
        (LEVEL2ID == 0 | LEVEL2ID == id[2]) & 
        (LEVEL3ID == 0 | LEVEL3ID == id[3]) & 
        (LEVEL4ID == 0 | LEVEL4ID == id[4] )& 
        (LEVEL5ID == 0 | LEVEL5ID == id[5]  ) 
      ] ) %>% unique()
  
  # setkeyv(dtDeptSelected, c(PSES_ID_COLS,"IDlevel"))
  setkeyv(dtDeptSelected, c(PSES_ID_COLS))
  
  return(dtDeptSelected)
}



getRESULTS <- function(id = c(83,200,304,0,0), aQs=c("Q43"), aYears=c(2018),depth=1) {
  if (  bPSES_READ==F) {
    print('getRESULTS(): PSES data NOT initialized ! -  Please Run readPsesData()')
    return (dtRESULT)
  }
  
  selectDepts (id)
  
  # dtRESULT <<- dtPSES[SURVEYR %in% aYears][
  #   selectDepts (id), on=PSES_ID_COLS][IDlevel<=levelID+depth][
  #     dtQuestions[QUESTION %in% aQs], on="QUESTION"]
  
  dtRESULT <<- dtPSES[SURVEYR %in% aYears][
    dtDeptSelected, on=PSES_ID_COLS][
      dtQuestions[QUESTION %in% aQs], on="QUESTION"]
  
  # dtRESULT <<- dtRESULT 
  
  setkeyv(dtRESULT, c(PSES_ID_COLS, "SURVEYR", "QUESTION"))
  
  if (dtRESULT[.N]$IDlevel == 0)
    dtRESULT <<-  dtRESULT[which.max(ANSCOUNT)]
  else {
    dtRESULT <<-  dtRESULT [, ':='(SCORE100=median(SCORE100), ANSCOUNT=max(ANSCOUNT)) ,
                            by=.(SURVEYR,QUESTION,Organization)] %>%
      unique(by=c("SURVEYR","QUESTION","Organization"))
  }
  #   
  
  # TO DO LATER - DO IT IN PSES !  FIX IT !!!
  # dt <- dtRESULT [, .(SCORE100=median(SCORE100), ANSCOUNT=max(ANSCOUNT)) , 
  #                by=.(SURVEYR,QUESTION,Organization)]
  # setkey(dt,Organization )
  # setkey(dtRESULT,Organization )
  # dtRESULT <- dtRESULT [dt] 
  # dtRESULT <- dtRESULT[, SURVEYR:Question.Abbreviated]
  
  
  
  return(dtRESULT)
}


if (F) { # NOT DONE
  #ID2OrgTree
  ID2OrgAboveBelow <- function(id) {
  }
  
  ID2IDAboveBelow
  selectDeptTree(myID)
  
  setkeyv(dtDepartments, PSES_ID_COLS[1:myLevel])    
  
  dtDeptSelected <<- 
    dtDepartments[as.list(id[1:myLevel])] %>% # get ALL children
    
    rbind(dtDepartments[                      # add ALL parents
      (LEVEL1ID == 0 | LEVEL1ID == id[1] ) & 
        (LEVEL2ID == 0 | LEVEL2ID == id[2]) & 
        (LEVEL3ID == 0 | LEVEL3ID == id[3]) & 
        (LEVEL4ID == 0 | LEVEL4ID == id[4] )& 
        (LEVEL5ID == 0 | LEVEL5ID == id[5]  ) 
      ] ) %>% unique()
  
}



#............................................................. ----

createPsesDepartments <- function() {
  
  strUrlDocumentation2018local  <- "source-data/2018_PSES_Supporting_Documentation_Document_de_référence_du_SAFF_2018.xlsx"
  dtDepartments <- read_excel(strUrlDocumentation2018local, sheet=6) %>% data.table();
  
  dtDepartments
  dtDepartments[, .N]; dtDepartments %>% names
  dtDepartments$`DESCRIPTION FR` <- NULL
  setnames(dtDepartments, old="DESCRIPTION ENG", new="Organization")
  dtDepartments[1]
  cols <- c("LEVEL1ID", "LEVEL2ID", "LEVEL3ID", "LEVEL4ID", "LEVEL5ID" )
  cols=1:5; 
  dtDepartments[, (cols):=lapply(.SD, as.integer), .SDcols=cols]; 
  
  
  # . Add PS (0.0.0.0.0)  ----
  dtDepartments <- dtDepartments %>% rbind(data.table(0L,0L,0L,0L,0L,"Public Service"), use.names=F)
  
  #. Truncate Dept name  -----
  dtDepartments$Organization.fullname <- dtDepartments$Organization
  dtDepartments[ , Organization:= Organization %>% str_trunc(50,side="center", ellipsis = "...") ]
  
  #. Replace `-`` to `/`` -----
  dtDepartments$Organization<- gsub("/", "-", dtDepartments$Organization ) 
  
  # . Add Acronyms (AADD) -----
  dtDepartments$AADD <-  abbreviate(dtDepartments$Organization, 1, named = FALSE)
  
  #NB: some Acronyms are the same !
  dtDepartments[, .(AADD,Organization)] #2404
  dtDepartments[, .(AADD,Organization)] %>% unique() # 2177: 
  
  for (i in 1:5) dtDepartments[, AADD := str_replace (AADD, '\\(', "")] 
  
  dtDepartments[, AADD := str_replace (AADD, "[[:lower:]]+", "")] 
  dtDepartments$AADD <- str_replace(dtDepartments$AADD, "[[]:punct:]]+", "")
  
  #for (i in 1:5) dtDepartments[, AADD := str_replace (AADD, "[:lower:]+", "")] 
  #for (i in 1:5) dtDepartments$AADD <- str_replace(dtDepartments$AADD, "[:punct:]+", "")
  #  dtDepartments[AADD == "I", AADD:= "N.A."]
  dtDepartments[AADD == "I", AADD:= "N/A"]
  
  
  
  # . Add IDlevel ----
  dtDepartments[ , IDlevel:=ifelse(LEVEL1ID == 0, 0, 
                                   ifelse(LEVEL2ID == 0, 1, 
                                          ifelse(LEVEL3ID == 0, 2, 
                                                 ifelse(LEVEL4ID == 0, 3, 
                                                        ifelse(LEVEL5ID == 0, 4, 5)))))]
  
  # . factor(dtDepartments$IDlevel----
  dtDepartments$IDlevel <- factor(dtDepartments$IDlevel,  levels = order(dtDepartments$IDlevel,decreasing=T))
  
  
  
  # . pathString: ORG_, LEV_  CBSA-HQ-ISTB-SED  ----
  
  if(T) {
    
    for (i in 1:nrow(dtDepartments))  {
      # if (dtDepartments[i,]$LEVEL2ID==999 | dtDepartments[i,]$LEVEL2ID==0)
      #   next;
      id <- dtDepartments[i, (PSES_ID_COLS),with=F] %>% unlist; id
      # if (getLevel(id)==0) 
      #   next
      ll <- getLevel(id);ll
      getIDupto(id,ll)
      
      #    dtDepartments[i, BB_DD:=""]
      setkeyv(dtDepartments, PSES_ID_COLS)
      
      for (l in 0:getLevel(id)) {
        # for (l in 1:getLevel(id)) {
        x <- dtDepartments[as.list(getIDupto(id,l))]$AADD ; #x %>% print
        xx <- dtDepartments[as.list(getIDupto(id,l))]$Organization.fullname %>% 
          str_trunc(40,ellipsis = "...")
        dtDepartments[i, paste0("LEV_", l):= x]
        dtDepartments[i, paste0("ORG_", l):= xx]
      }
    }
    
    dtDepartments[ , pathString:=paste(LEV_1, LEV_2,LEV_3,LEV_4, sep = "/")]
    for (i in 1:5) dtDepartments[, pathString := str_replace (pathString, '/NA', "")] 
    
    # dtDepartments[IDlevel==0, pathString:="All Public Service"]
    # dtDepartments[IDlevel==1, pathString:=AADD]
  }
  
  # . Order by Key and Add order number: .I -----
  setkeyv(dtDepartments, PSES_ID_COLS)
  dtDepartments[, I:= .I]
  
  # .[ remove 999. ie. "I can't find my unit"] -----
  
  # .. Test Uniqueness of names,Org,pathString-----
  dtDepartments %>% nrow() # [1] 2404
  dtDepartments$Organization %>% unique() %>% length()# [1] 2177
  dtDepartments$pathString %>% unique() %>% length()# [1] 2206 2267
  dtDepartments$AADD %>% unique() %>% length()# [1] 1997
  
  samePaths <- dtDepartments[, .N, by=pathString][N>1]$pathString
  dtDepartments[pathString %in% samePaths]
  
  #. [ order decreasing = T ] ----
  # dtDepartments <- dtDepartments[order(Organization, decreasing = T)]
  
  # . Save -----
  dtDepartments[,.N];   dtDepartments %>% names
  dtDepartments[c(1,.N)]
  dtDepartments[LEVEL1ID==83]
  fwrite(dtDepartments, "dtDepartments.csv", sep="\t"); 
  #dtDepartments <- fread("dtDepartments.csv")
}
#. createPsesDepartments ----
if (F)
  createPsesDepartments()

#.................................................... ----

createPsesQuestions <- function() {
  
  strUrlDocumentation2018local  <- "source-data/2018_PSES_Supporting_Documentation_Document_de_référence_du_SAFF_2018.xlsx"
  dtQuestions <- read_excel(strUrlDocumentation2018local, sheet=3) %>% data.table();
  
  dtQuestions[,.N];   dtQuestions %>% names
  dtQuestions$Français <- NULL
  setnames(dtQuestions, c("QUESTION", "Question"))
  
  assignThemesToQuestions <- function(.dtQuestions) {
    
    # lThemes: 36 main questions :  22 + 5+ 4 + 5 
    # 43: Would you recommend
    
    lTheme <- list()
    lTheme[[6]] <- list(Qs=c("Q06", "Q18", "Q19", "Q20"), str = "Performance management")
    lTheme[[5]] <- list(Qs=c("Q23", "Q24", "Q26"), str = "My Immediate Supervisor")
    lTheme[[4]] <- list(Qs=c("Q28", "Q29", "Q30", "Q31", "Q32"), str = "Senior Management") # ==
    lTheme[[3]] <- list(Qs=c("Q33", "Q34", "Q36", "Q37", "Q40"), str = "Ethical Workplace")
    lTheme[[2]] <- list(Qs=c("Q41",  "Q44", "Q45", "Q64","Q65"), str = "Respectful & Healthy Workplace") #"Q42", "Q43",
    lTheme[[7]] <- list(Qs=c("Q48","Q54","Q55","Q60",'Q61'), str ="Harassment & Discrimination") #
    # lTheme[[7]] <- list(Qs=c("Q64","Q65"), str = "Healthy workplace") # ,"Q66", "Q63",
    #lTheme[[8]] <- list(Qs=c("Q42","Q43","Q44","Q63",'Q66'), str ="Overall stress and satisfaction") # Stress and well-being.
    lTheme[[1]] <- list(Qs=c("Q42","Q43","Q44","Q63",'Q66'), str ="Stress and Overall") # Overall Environment"
    
    #lTheme[[8]] <- list(Qs=c("Q67","Q71",'Q72', "Q73"), str ="Phoenix & Pay issues") # "70"
    
    
    
    # dtPSES[str_length(QUESTION)<=3 & SCORE100>100, .N, QUESTION]$QUESTION 
    # [1] "Q46", "Q47", "Q69", "Q70"  
    # 
    if (F) {
      
      # REDUNDANT 
      aQuestions22 <- c("Q06", "Q18", "Q19", "Q20", 
                        "Q23", "Q24", "Q26", 
                        "Q28", "Q29", "Q30", "Q31", "Q32", 
                        "Q33", "Q34", "Q36","Q37", "Q40", 
                        "Q41", "Q42", "Q43", "Q44", "Q45",
                        
                        "Q48","Q54","Q55","Q60",'Q61',
                        "Q63","Q64","Q65","Q66",
                        "Q67","Q71",'Q72', "Q73"
      )
    }
    
    
    
    for (i in 1:length(lTheme)) {
      .dtQuestions[ QUESTION %in% lTheme[[i]]$Qs, ':='(Theme=lTheme[[i]]$str, nTheme=i)]
    }
    
    .dtQuestions
  }
  
  
  # . assign Themes ----
  dtQuestions <- assignThemesToQuestions(dtQuestions)
  dtQuestions <- dtQuestions[!is.na(Theme)] # LEave only OUR 35 questions
  dtQuestions$Question %>% unique()
  
  # . clean, abbreviate ----
  for (i in 1:4) dtQuestions[, Question := str_replace (Question, '\\n+', " ")] 
  for (i in 1:4) dtQuestions[, Question := str_replace (Question, '\\r+', " ")]
  
  dtQuestions$Question.Abbreviated <- gsub("Question ", "", dtQuestions$Question) %>% str_trunc(90,ellipsis = "..") 
  
  if (F) {
    dtQuestions[, Question.Abbreviated := str_replace (Question.Abbreviated, '[:digit:]+', "")]
    dtQuestions[, Question.Abbreviated := str_replace (Question.Abbreviated, '. ', "")]
  }
  
  dtQuestions$Question <- dtQuestions$Question %>% str_trunc(158,ellipsis = "..") 
  
  if (F) {
    dtQuestions$Question <- dtQuestions$Question %>% 
      str_wrap(90, exdent=2)
  }
  #   #thanks <- word(thanks, 1, 3, fixed("\n\n")) # to break by end of line
  
  
  # . Sort: Add factor to sort----
  if (T) { 
    dtQuestions$Question <- factor(dtQuestions$Question, 
                                   levels = dtQuestions$Question[order(dtQuestions$nTheme)])
    dtQuestions$QUESTION <- factor(dtQuestions$QUESTION, 
                                   levels = dtQuestions$QUESTION[order(dtQuestions$nTheme)])
    # WORKS
    dtQuestions$Question.Abbreviated <- factor(dtQuestions$Question.Abbreviated, 
                                               levels = dtQuestions$Question.Abbreviated[order(dtQuestions$nTheme)])
    #dtQuestions[ , Question.Abbreviated := ordered(Question.Abbreviated, levels = Question.Abbreviated[order(nTheme)])  ]
    
    
    #dtQuestions$Question.Abbreviated <- as.character(dtQuestions$Question.Abbreviated)
    #dtQuestions <- dtQuestions[order(QUESTION, decreasing = F)]
    #setkey(dtQuestions, -QUESTION)
  }
  
  # . save ----
  setkey(dtQuestions, QUESTION)
  dtQuestions[,.N];   dtQuestions %>% names
  fwrite(dtQuestions, "dtQuestions.csv", sep="\t"); 
  
}
#. createPsesQuestions ----
if (F)
  createPsesQuestions ()

#............................................................... ----

createPsesScores <- function() {
  
  if (F) {  # I. Read 2018 only  ----
    strUrl2018local <- "source-data/2018_PSES_open_dataset_Ensemble_de_données_ouvertes_du_SAFF_2018.csv"
    dtPSES <<- fread(strUrl2018local); 
    
    if (T) { # . Keep 2018 only 
      dtPSES[ , .N, by = SURVEYR]
      dtPSES[SURVEYR == 2018 ] # 1062480:  
      ## dtPSES <<- dtPSES [SURVEYR==2018] 
    }
  } else { # II. Read 2011-2018 files ---- 
    
    # THIS NEEDS TO BE VALIDATED
    
    
    ########################################################### #
    #  0.Read dtQmapping  ---- 
    ########################################################### #
    #Question number concordance with past surveys
    
    #https://www.canada.ca/en/treasury-board-secretariat/services/innovation/public-service-employee-survey/2018/question-number-concordance-past-surveys-2018.html
    
    if (F) {
      strFile <- "source-data/PSES-SED-2011-2018.xls" 
      dtQmapping <- read_excel(strFile, sheet=4) %>% data.table()
      
      cols <- c("n2018", "n2017","n2017a","n2014","n2011","n2008")
      setnames(dtQmapping,c("Question", cols))
      
      # for (c in cols) {
      #   dtQmapping[as.name(c)=="N/A", c:=NA]
      # }
      dtQmapping  
      
      fwrite(dtQmapping, "dtQmapping.csv", sep="\t"); 
    } else{
      dtQmapping <- fread("dtQmapping.csv"); 
    }
    
    cols <- c("n2018", "n2017","n2017a","n2014","n2011","n2008")
    dtQmapping[, (cols):=lapply(.SD, as.integer), .SDcols=cols]
    dtQmapping[, (cols):=lapply(.SD, function(x) sprintf("Q%02i",x)), .SDcols=cols]
    dtQmapping[, (cols):=lapply(.SD, function(x) ifelse(x=="QNA", NA, x)), .SDcols=cols]
    dtQmapping
    
    #. Read 2011-2018 .csv data ----
    strUrl2018local <- "source-data/2018_PSES_open_dataset_Ensemble_de_données_ouvertes_du_SAFF_2018.csv"
    strUrl2017local  <- "source-data/2017_PSES_SAFF_Open_dataset_Ensemble_donnees_ouvertes.csv"
    strUrl2014local  <- "source-data/2014-results-resultats.csv"
    strUrl2011local  <- "source-data/2011_results-resultats.csv"
    
    dt2011 <- fread(strUrl2011local); dim(dt2011)# 22 cols
    dt2014 <- fread(strUrl2014local); dim(dt2014)# 23 cols
    dt2017 <- fread(strUrl2017local); dim(dt2017)# 23 cols
    dt2018<- fread(strUrl2018local); dim(dt2018)
    
    
    #. Remove AGREE column in 2014-2018 .csv data ----
    dt2014$AGREE <- NULL
    dt2017$AGREE <- NULL
    dt2018$AGREE <- NULL
    
    
    #. Rename QUESTION column in 2011  so we can merge by it----
    setnames(dt2011, "V9", "QUESTION");     dt2011 %>% names
    
    # . Rename question numbers in each set ----
    dt2018$QUESTION %>% unique #  Q01 2312923: 
    dt2017$QUESTION %>% unique # A_Q01 3289210:  
    dt2014$QUESTION %>% unique# A_Q01 1509724:  
    dt2011$QUESTION %>% unique# A_Q01  1069189: 
    
    dt2017[, QUESTION := QUESTION %>% substring(3)]
    dt2014[, QUESTION := QUESTION %>% substring(3)]
    dt2011[, QUESTION := QUESTION %>% substring(3)]
    
    
    
    # . * Replace question via mapping  ----
    dt2011[
      dtQmapping,
      on = c(QUESTION = "n2011"),
      QUESTION := n2018
      ]
    
    dt2014[
      dtQmapping,
      on = c(QUESTION = "n2014"),
      QUESTION := n2018
      ]
    
    dt2017[
      dtQmapping,
      on = c(QUESTION = "n2017"),
      QUESTION := n2018
      ]     
    
    # . rbind them together (dt2011-2018) ----
    dtPSES <- dt2018 %>% rbind(dt2017) %>% rbind (dt2014) %>% rbind(dt2011, use.names=F)
    
    rm(dt2018);  rm(dt2017);  rm(dt2014);  rm(dt2011); 
  }
  
  # >>> Post Process PSES #######################################################
  ##  
  dtPSES[c(1,.N)]; names(dtPSES) # 23 cols
  dtPSES %>% dim # 8181046      22
  dtPSES$QUESTION %>% unique()
  dtPSES[, .N, by = SURVEYR]
  
  if (T) { # . Leave two-digit questions only  ----
    dtPSES <- dtPSES[str_length(QUESTION)<=3]
  }
  
  if (F) { # .Leave  dtQuestions (22 or 35) only ----
    if (dtQuestions %>% nrow == 0) {
      print("createPsesScores(): dtQuestions has 0 rows!")
    } else {
      dtPSES <- dtPSES [QUESTION %in% (dtQuestions$QUESTION %>% unique)]
    }
  }
  
  # .Leave needed columns only ----
  
  cols <- c("LEVEL1ID", "LEVEL2ID", "LEVEL3ID", "LEVEL4ID", "LEVEL5ID", "SURVEYR", "QUESTION", "ANSWER1",  "ANSWER2",  "ANSWER3",  "ANSWER4",  "ANSWER5", "SCORE100", "ANSCOUNT")
  
  dtPSES <- dtPSES[ , cols, with=F]
  dtPSES %>% names;   dtPSES[1:2]
  
  dtPSES [, .N, by = SURVEYR ]
  dtPSES[SURVEYR == 2018 ] # 1062480 --> 283257:
  dtPSES %>% nrow  # --> 792546      b) 2312923 ,   - 8181046  
  dtPSES %>% unique() # --> 771020 , b) 2237858 , 2237817 - 7187044
  dtPSES <- dtPSES %>% unique() 
  
  if (T){ # . FIX dtPSES[SCORE100>100, QUESTION]----
    dtPSES[SCORE100>100, QUESTION]
    
    dtPSES [QUESTION %in% c( "Q48","Q55"), SCORE100:= ANSWER2  ]
    dtPSES [QUESTION %in% c( "Q48","Q55") & SCORE100>100 ] # 0
    
    dtPSES[str_length(QUESTION)<=3 & SCORE100>100 , SCORE100:= 77]
  }
  
  # >> DEAL / REMOVE UMBIGUOUS (ensure  they are sorted down !  ----
  
  
  if (F) {  # not working
    
    # . handle multiple answers ----    
    dtAll[ ,.N, by=.(SURVEYR,QUESTION,Organization)][N>1] # 1979: 
    
    
    dtAll <<-  dtAll [, ':='(SCORE100=median(SCORE100) %>% as.integer(), ANSCOUNT=max(ANSCOUNT)) ,
                      by=.(SURVEYR,QUESTION,Organization)]
    dtAll <<- dtAll %>% unique(by=c("SURVEYR","QUESTION","Organization"))
  }
  
  dtPSES %>% nrow() # 3278338
  
  #       # 1. WHY Many responses for the same question (cols) in x-0-0-0-0 ??? ----
  #     
  # ... examine the problem ----
  # 
  
  if(F) { 

    qq <- quote (LEVEL1ID == 83 & LEVEL2ID == 0 & LEVEL3ID == 0 & LEVEL4ID == 0 & LEVEL5ID == 0 )
    dtPSES[eval(qq)  & SURVEYR==2018 & QUESTION == "Q43"][, .(.N, SCORE100, ANSCOUNT), by=cols][N>1]
    dtPSES[eval(qq) & SURVEYR == 2018 & QUESTION == "Q43"][order(ANSCOUNT, decreasing = T)] [, .(SCORE100,ANSCOUNT)] %>% plot
    
    dtPSES[eval(qq)  & SURVEYR == 2017 & QUESTION == "Q43"][order(ANSCOUNT, decreasing = T)][, .(SCORE100,ANSCOUNT)] %>% plot # 145 rows: 6228
    dtPSES[eval(qq)  & SURVEYR==2017 & QUESTION == "Q43"][, .(.N, SCORE100, ANSCOUNT), by=cols][N>1]
    
    dtPSES[eval(qq) &  LEVEL5ID == 0 & SURVEYR == 2014 & QUESTION == "Q43"][order(ANSCOUNT, decreasing = T)][, .(SCORE100,ANSCOUNT)] %>% plot # 145 rows: 6228
    dtPSES[eval(qq)  & SURVEYR==2014 & QUESTION == "Q43"][, .(.N, SCORE100, ANSCOUNT), by=cols][N>1]  
    
    dtPSES[eval(qq) &  LEVEL5ID == 0 & SURVEYR == 2011 & QUESTION == "Q43"][order(ANSCOUNT, decreasing = T)][, .(SCORE100,ANSCOUNT)] %>% plot # 145 rows: 6228
    dtPSES[eval(qq)  & SURVEYR==2011 & QUESTION == "Q43"][, .(.N, SCORE100, ANSCOUNT), by=cols][N>1]      
    
  }
  remove_extra_rows_with0s_in_LEVELS <- function(dt) {
    
    cols <- c("LEVEL1ID" ,"LEVEL2ID" ,"LEVEL3ID" ,"LEVEL4ID", "LEVEL5ID", "QUESTION", "SURVEYR")
    setkeyv(dtPSES, cols);
    dtPSES[, .N, by=cols] # 74558,  260204: - 83742:  
    dtPSES[, .N, by=cols][N>1] # 6824, 22656 : -  7273: 
    
    setorderv(dtPSES, c(cols, "ANSCOUNT"), c(rep(1,length(cols)), -1))
    #setorder(dt0, -ANSCOUNT);        dt0 # 594 , 625 1153  0-0-0-0-0, 145
    # 
    
    if (T) {
      # ...  Approach 1: Take Score from the largest ANSCOUNT. ----
      #Alternatively, I can recompute  "SCORE100"
      
      
      dtPSES %>% nrow # 771020  , 825479
      dtPSES <<- dtPSES %>% unique(by=cols) # 83742 !!!!
      dtPSES %>% nrow # 74558, 244885 # OR 244742 , 260204 (if  dtPSES [SURVEYR==2018])
      dtPSES [, .N, by = SURVEYR ]
      dtPSES [, .N, by = .(SURVEYR,QUESTION) ]
    }
    if (F) {  # ... Approach 2: take average, median,mode or Maximum ----
    }
    
    if (F) {  # ... [ Alt.approach: recompute ANSCOUNT ----
      
      # dt0 <- dtPSES [LEVEL2ID == 0]
      # for (c in paste0("ANSWER",1:5)) {
      #   dt0[, as.name(paste0(c,"_t")):= as.name(c)*"ANSCOUNT", with=T]
      # }
      # for (c in paste0("ANSWER",1:5)) {
      #   dt0[, get(paste0(c,"_t")):= get(c)*ANSCOUNT,]
      # }
      # dt0[, SCORE100.new:= (100*ANSWER1*ANSCOUNT + 75*ANSWER2*ANSCOUNT + 50*ANSWER3*ANSCOUNT + 25*ANSWER4*ANSCOUNT) / (ANSWER1*ANSCOUNT + ANSWER2*ANSCOUNT + ANSWER3*ANSCOUNT +ANSWER4*ANSCOUNT + ANSWER5*ANSCOUNT), 
      #     by=.(LEVEL1ID, SURVEYR, QUESTION)]
      # 
      # dt0 <- dtPSES [LEVEL2ID == 0, 
      #                SCORE100.new:= (100*ANSWER1*ANSCOUNT + 75*ANSWER2*ANSCOUNT + 50*ANSWER3*ANSCOUNT + 25*ANSWER4*ANSCOUNT) / (ANSWER1*ANSCOUNT + ANSWER2*ANSCOUNT + ANSWER3*ANSCOUNT +ANSWER4*ANSCOUNT + ANSWER5*ANSCOUNT), 
      #                by=.(LEVEL1ID, SURVEYR, QUESTION)]
      
    }
    
  }
  
  dtPSES <- remove_extra_rows_with0s_in_LEVELS(dtPSES)
  
  
  if (F) { # no work
    #. assign rank to each Org for each Q. at each Year ----
    dtPSES$RANK100 <- 50
    
    #setkeyv(dtPSES, c("Organization", "SURVEYR", "QUESTION")
    setkeyv(dtPSES, c(PSES_ID_COLS, "SURVEYR", "QUESTION"))
    org  <- (dtAll$Organization %>% unique)[6];org
    y=2018
    q <- (dtAll$QUESTION %>% unique)[2];q
    
    if (F) {
      dtAll[c(org,y,q)][,.N] # returns 33 lines (org,y, 33 questions)
      dtAll[as.list(org,y,q)]#        the same as above 
      dtAll[.(org,y,q)]  # returns 1 line -- CORRECT
      dtAll[Organization == org & SURVEYR==y & QUESTION==q] # the same as above    
    }
    
    for (org in dtAll[IDlevel > 0]$Organization %>% unique) {
      for (y in dtAll[Organization == org]$SURVEYR %>% unique){
        for (q in dtAll$QUESTION %>% unique) {
          myScore <- dtAll[.(org,y,q)]$SCORE100; myScore
          myRank <- dtAll[QUESTION==q & SURVEYR==y &  SCORE100 > myScore, .N] ; myRank
          TOTAL <- dtAll[QUESTION==q & SURVEYR==y , .N]; TOTAL
          dtAll[.(org,y,q), RANK100:=round(myRank/TOTAL*100)]
          # set(dtAll,QUESTION==q, RANK100:=round(RANK/TOTAL*100)]
        }
      }
      
    }
    
    if (F) {       # . validate and save  ----
      dtPSES[, .N, by=SURVEYR]
      dtPSES[1:2]
      dtPSES[LEVEL1ID==63, .N, by=.(SURVEYR, QUESTION, 
                                    LEVEL1ID, LEVEL2ID, LEVEL3ID, LEVEL4ID, LEVEL5ID)]
      dtPSES$QUESTION %>% unique
    }
    
    fwrite(dtPSES, "dtPSES.csv", sep="\t"); 
  }
}
#.  createPsesScores ()
if (F)
  createPsesScores ()


######################################################## #
######################################################## #
#readDataFromOpenCanada <- function() {
#  NEVER read URL for now
# strUrlDocumentation2018 <- 
#   "https://www.canada.ca/content/dam/tbs-sct/documents/datasets/pses-saff/2018/2018_PSES_Supporting_Documentation_Document_de_r%C3%A9f%C3%A9rence_du_SAFF_2018.xlsx"
#    strUrl2018 <-.strUrl2018 
# "https://www.canada.ca/content/dam/tbs-sct/documents/datasets/pses-saff/2018/2018_PSES_open_dataset_Ensemble_de_donn%C3%A9es_ouvertes_du_SAFF_2018.csv"
# strUrl2017 <- 
#   "https://www.canada.ca/content/dam/tbs-sct/documents/datasets/pses-saff/2017/2017_PSES_SAFF_Open_dataset_Ensemble_donnees_ouvertes.csv"
# strUrl2014 <-
#   "https://www.canada.ca/content/dam/canada/tbs-sct/migration/psm-fpfm/modernizing-modernisation/pses-saff/source-data/2014-results-resultats.csv"
# strUrl2011 <- 
#   "http://www.tbs-sct.gc.ca/pses-saff/2011/source-data/PSES-SAFF2011_OverallPS.csv"

#}


############################################################################### #
############################################################################### #


# . data.tree -----

buildOrgChartTree <- function() { 
  
  
  dtRESULT[ , pathString:=paste(LEVEL1ID, LEVEL2ID,LEVEL3ID,LEVEL4ID,LEVEL5ID, SCORE100, sep = "/")]
  # dtRESULT[, LEVEL5ID:=SCORE100]
  
  dtRESULTtree <- as.Node(dtRESULT)
  print(dtRESULTtree,"SURVEYR", "QUESTION") 
  plot(dtRESULTtree) 
  
}

if (F){
  library(data.tree)
  
  year=2018; nQ="Q43"
  dtPSES0 <- dtPSES [as.list(83,200,304,0,0)][SURVEYR == year & QUESTION == nQ]
  
  dtPSES0[ , pathString:=paste("NHQ", LEVEL4ID,LEVEL5ID, sep = "/")]
  
  treePSES0 <- as.Node(dtPSES0)
  print(treePSES0, "SCORE100", "ANSCOUNT", limit = 100)
  
  plot(treePSES0)

}



# .......................................... -----
# 
# _______TEST IT _______ ####


readPsesData <- function ()  {
  #. read *.csv ----
  dtPSES <<- fread("dtPSES.csv")
  dtQuestions <<- fread("dtQuestions.csv")
  dtDepartments <<- fread("dtDepartments.csv")
  
  dtAll <<- dtPSES[dtDepartments, on=PSES_ID_COLS][dtQuestions, on="QUESTION"]
  
  if (F) {  
    
    # . handle multiple answers ----    
    dtAll[ ,.N, by=.(SURVEYR,QUESTION,Organization)][N>1] # 1979: 
    
    
    dtAll <<-  dtAll [, ':='(SCORE100=median(SCORE100) %>% as.integer(), ANSCOUNT=max(ANSCOUNT)) ,
                      by=.(SURVEYR,QUESTION,Organization)]
    dtAll <<- dtAll %>% unique(by=c("SURVEYR","QUESTION","Organization"))
  }
  
  if (F) {
    #. assign rank (wrt All PS & Level=1 <-- TODO) to each (Org,Q,Year) ----
    
    dtAll$RANK100 <- 50
    
    setkey(dtAll, Organization, SURVEYR, QUESTION)
    org  <- (dtAll$Organization %>% unique)[6];org
    y=2018
    q <- (dtAll$QUESTION %>% unique)[2];q
    
    dtAll[c(org,y,q)] # returns 33 lines (org,y, 33 questions)
    dtAll[as.list(org,y,q)]#        the same as above 
    dtAll[.(org,y,q)]  # returns 1 line -- CORRECT
    dtAll[Organization == org & SURVEYR==y & QUESTION==q] # the same as above    
    
    
    for (org in dtAll[IDlevel > 0]$Organization %>% unique) {
      for (y in dtAll[Organization == org]$SURVEYR %>% unique){
        for (q in dtAll$QUESTION %>% unique) {
          myScore <- dtAll[.(org,y,q)]$SCORE100; myScore
          myRank <- dtAll[QUESTION==q & SURVEYR==y &  SCORE100 > myScore, .N] ; myRank
          TOTAL <- dtAll[QUESTION==q & SURVEYR==y , .N]; TOTAL
          dtAll[.(org,y,q), RANK100:=round(myRank/TOTAL*100)]
          # set(dtAll,QUESTION==q, RANK100:=round(RANK/TOTAL*100)]
        }
      }
    }
    
    # . save ----
    fwrite(dtAll, "dtPSES-merged+rank.csv",  sep="\t")
    dtAll <- fread("dtPSES-merged+rank.csv.csv") 
    
    
  }
  
  bPSES_READ <<- T
  
  #. test: dtResults <- dtAll[ myID ] ----
  
  if(T) {
    
    dtResults <<- dtAll[QUESTION==myQ & SURVEYR==myYear]; 
    
    # .. for myID: dtResultsMy ----
    
    setkeyv(dtResults, PSES_ID_COLS)
    dtResultsMy <- dtResults[as.list(myID)] #TODO test it !!
    
    # #OR (HOWEVER NB: Organization are not UNIQUE!)
    # dtResults <<- dtAll[Organization == ID2Org(myID) &
    #         QUESTION==myQ & SURVEYR==myYear
    #       ][,  .(SURVEYR,QUESTION,Organization, SCORE100)]; dtResults
    
    # .. for children: dtResultsBelow---
    setkeyv(dtResults, PSES_ID_COLS[1:(which.min(myID)-1)])
    dtResultsBelow  <- dtResults[as.list(myID[1:(which.min(myID)-1)])]
    
    
    # .. for parents: dtResultsAbove---
    dtResultsAbove <- dtResults[
      (LEVEL1ID == 0 | LEVEL1ID == myID[1] ) & 
        (LEVEL2ID == 0 | LEVEL2ID == myID[2]) & 
        (LEVEL3ID == 0 | LEVEL3ID == myID[3]) & 
        (LEVEL4ID == 0 | LEVEL4ID == myID[4] )& 
        (LEVEL5ID == 0 | LEVEL5ID == myID[5]  ) 
      ]
    
  }
  
  
}



